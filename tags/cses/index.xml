<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSES on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/cses/</link><description>Recent content in CSES on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 03 Oct 2022 22:39:07 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/cses/index.xml" rel="self" type="application/rss+xml"/><item><title>CSES Josephus Queries</title><link>https://snow-ham1949.github.io/posts/cses-josephus-queries/</link><pubDate>Mon, 03 Oct 2022 22:39:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-josephus-queries/</guid><description>題目 給 $n$ 個圍成一圈的小孩，每 2 個人就移掉 2 個人中的第二個，問第 $k$ 個小孩被移掉的編號
作法 這題網路上有很多題解，我看的懂 tutorial 但實作都看不懂所以寫一下。 ps 是我隊友教我的她好棒
因為圍成一圈，所以說我們可以把要移掉的數目看成是 $\frac{n + 1}{2}$，這樣一來如果 $n$ 是奇數，被移掉的就會是所有的偶數跟 1，反之則是移掉所有的偶數。
那麼遞迴下去做的話，可以看成是把該移掉的人移掉之後重新編號成 1, 2, 3, &amp;hellip;，再把 index remap 回來，所以這時候就要看原本是奇數還是偶數來決定怎麼 remap。
舉例來說，如果 $n$ 是奇數，那第一輪拿完會變成 3, 5, 7, &amp;hellip;, n，這樣重新編號成 1, 2, 3, &amp;hellip;，就要 $2 \times \text{id} + 1$ remap 回來。如果 $n$ 是偶數的話，那第一輪拿完會變成 1, 3, 5, 7, &amp;hellip;, n，這樣重新編號成 1, 2, 3, &amp;hellip;，就要 $2 \times \text{id} - 1$ remap 回來。</description></item><item><title>CSES Tree Matching</title><link>https://snow-ham1949.github.io/posts/cses-tree-matching/</link><pubDate>Mon, 19 Sep 2022 21:51:48 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-tree-matching/</guid><description>第一次接觸樹 dp OuO
題目 給一棵樹，找到最大的邊集合使得任兩邊不共享一個點，輸出集合大小。
作法 定義 如果是 array 版本的話（i.e. 給一個序列不能選相鄰的，最大化價值），比較容易可以想到轉移式 $dp(i) = max(v_i + dp(i - 2), dp(i - 1))$
轉成樹的版本的話，就需要在樹上面做 dp，對於一個節點 $u$ 有下面兩種情況
取一條跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_0(u)$ 不取任何跟 $v \in child(u)$ 有連接的邊，答案定義為 $dp_1(u)$ 為什麼沒有取兩條以上的 case 呢？因為如果取兩條以上的話 $u$ 就會變成那個共享的點。
所以從上面的定義可以知道答案是 $max(dp_0(1), dp_1(1))$
轉移式 $dp_1(u)$
因為不取任何跟 $v \in child(u)$ 有連接的邊，所以不管「跟 $v$ 的小孩有連接的邊」取不取都可以，所以答案就是
$dp_1(u) = \sum_{v \in child(u)} max(dp_0(v), dp_1(v))$
$dp_0(u)$
可以先處理取一條的部分，因為取了 $u \rightarrow v$ 這一條，所以「不取任何跟 $w \in child(v)$ 有連接的邊」是 $dp_1(v)$，再加上 $u \rightarrow v$ 這一條，就是 $dp_1(v) + 1$。 接下來要加上 $w \in child(u), w \neq v$ 的部分，畫一下圖就會發現就是</description></item><item><title>CSES List Removals</title><link>https://snow-ham1949.github.io/posts/cses-list-removals/</link><pubDate>Sun, 18 Sep 2022 19:18:46 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-list-removals/</guid><description>題目 給定一個長度為 $n$ 的序列 $a$，給 $n$ 個詢問，對於每個詢問 $pos$，輸出位置為 $pos$ 的值並從序列中刪除。
作法 這題的技巧要用到「BIT 上二分搜」，可以想像如果一個數字還沒有被刪除，我們就將它的 presentation 記為 $1$，反之則為 $0$，那麼查詢位置在 $pos$ 的元素等於就是查找前綴和為 $pos$，且 presentation = 1 的位置。
至於二分搜要怎麼實作呢，BIT 的節點是根據 2 的冪次劃分的，所以每次可以嘗試擴展 2 的冪次，看現在的前綴和是不是小於詢問，如果是的話代表可以擴展。等於說我們在找 $\sum_{i = 1}^x presentation[i] &amp;lt; pos$ 的 $x$，如果現在的和還比詢問小的話就可以擴展。所以一路這樣擴展下去之後，我們會找到最大的 $x$ 符合上式，那麼 $x + 1$ 就是答案。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; const int mxn = 2e5 + 5; int n, a[mxn]; int bits(int x) { // floor(log2(x)) return x == 0 ?</description></item><item><title>CSES Hotel Queries</title><link>https://snow-ham1949.github.io/posts/cses-hotel-queries/</link><pubDate>Sat, 17 Sep 2022 23:13:51 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-hotel-queries/</guid><description>題目 給一個序列 $a$，對於每個詢問 $x$ 找到最小的 $i$ 使得 $a[i] &amp;gt;= x$，並將 $a[i] -= x$。
作法 這題要用到的技巧是線段樹二分搜。
線段樹的每個節點可以存「節點包含的區間內最大的數」，所以對於每個詢問 $x$，我都可以去看是下面哪個 case
左子樹的最大值 $&amp;gt;= x$ -&amp;gt; 往左子樹遞迴查詢 右子樹的最大值 $&amp;gt;= x$ -&amp;gt; 往右子樹遞迴查詢 都小於 -&amp;gt; 答案 $= 0$ 實作就看 code
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; const int mxn = 2e5 + 5; int ans; struct Seg { ll seg[mxn &amp;lt;&amp;lt; 2], a[mxn]; void pullup(int id) { seg[id] = max(seg[id &amp;lt;&amp;lt; 1] , seg[id &amp;lt;&amp;lt; 1 | 1]); } void build(int l, int r, int id = 1) { if (l == r) { seg[id] = a[l]; return; } int mid = (l + r) &amp;gt;&amp;gt; 1; build(l, mid, id &amp;lt;&amp;lt; 1); build(mid + 1, r, id &amp;lt;&amp;lt; 1 | 1); pullup(id); } void bs(int l, int r, ll val, int id = 1) { // binary search on segment tree if (l == r) { if (seg[id] &amp;gt;= val) ans = l; seg[id] -= val; return; } int mid = (l + r) &amp;gt;&amp;gt; 1; if (seg[id &amp;lt;&amp;lt; 1] &amp;gt;= val) bs(l, mid, val, id &amp;lt;&amp;lt; 1); else if (seg[id &amp;lt;&amp;lt; 1 | 1] &amp;gt;= val) bs(mid + 1, r, val, id &amp;lt;&amp;lt; 1 | 1); pullup(id); } } seg; void solve() { int n, q; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q; for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; seg.</description></item><item><title>Sparse Table</title><link>https://snow-ham1949.github.io/posts/sparse-table/</link><pubDate>Sun, 04 Sep 2022 22:13:25 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/sparse-table/</guid><description>能幹嘛 區間最小/最大查詢，利用可以把區間拆成 $\log_2(\text{區間長度})$ 個長度為 2 的冪次的區間，達到 $O(N\log(N))$ pre-build, $O(1)$ 查詢。 （區間和查詢也可以，不過是 $O(\log(N))$，而且可以用前綴和 $O(1)$）
舉例來說，$[2, 10]$ 是一個長度為 9 的區間，那他就可以被拆成 $[2, 9] \cup [10, 10]$，如果我可以提前知道這兩個區間的答案，那我就知道組合起來的答案。
建 st 表的話可以看下面例題的 code， $st[i][j] :=$ 從 $i$ 開始長度為 $2^j$ 的區間的答案，那因為這樣的區間可以再拆成兩個長度為 $2^{j - 1}$ 的區間，所以可以用這兩個區間求答案。
btw 缺點是如果陣列值有改動的話就要重蓋 st 表，所以適用於不會改值的時候用。
例題 CSES-Static Range Minimum Queries
作法
就是 sparse table 模板題，不過這題的話不用跟求 sum 一樣拆成好幾個不重疊的區間，因為求 min 的話就算拆成兩個重疊的也沒關係，所以就暴力拆成兩個 $\log(r - l + 1)$ 長度的區間就可以查詢了。
code
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; const int mxn = 2e5 + 5; const int logn = 19; int st[mxn][logn]; // sparse table, store answer for [i, i + 2^j - 1] int a[mxn]; // array int lg[mxn]; // log value int n, q; void init() { lg[1] = 0; for (int i = 2; i &amp;lt; mxn; i++) lg[i] = lg[i / 2] + 1; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; st[i][0]; for (int j = 1; j &amp;lt; logn; j++) { for (int i = 0; i + (1 &amp;lt;&amp;lt; j) &amp;lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]); } } } void solve() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q; init(); while (q--) { int l, r; cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r; l--, r--; int j = lg[r - l + 1]; cout &amp;lt;&amp;lt; min(st[l][j], st[r - (1 &amp;lt;&amp;lt; j) + 1][j]) &amp;lt;&amp;lt; endl; } } int main() { ios::sync_with_stdio(0);cin.</description></item><item><title>CSES Round Trip</title><link>https://snow-ham1949.github.io/posts/cses-round-trip/</link><pubDate>Sun, 27 Feb 2022 22:41:56 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-round-trip/</guid><description>我一直以為我會找環欸，結果其實是我會找但要印出來就不會，我就笨 :p
題目 link 找圖中隨便一個環然後印路徑，如果沒有就輸出 IMPOSSIBLE。
作法 就是 dfs 一下(?)，最近在試著改掉開全域的壞習慣 :p，主要是我想要怎麼記祖先想很久，覺得開 parent 陣列又太肥，後來想到當參數傳下去不就好了嗎，笨笨的 :p
#include &amp;lt;bits/stdc++.h&amp;gt; #define AC \ ios::sync_with_stdio(0); \ cin.tie(0); \ cout.tie(0); using namespace std; #define DEBUG void dfs(int id, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;vis, vector&amp;lt;int&amp;gt; &amp;amp;path, int parent) { vis[id] = true; path.push_back(id); for (int nei : adj[id]) { if (nei == parent) { continue; } if (vis[nei]) { path.push_back(nei); int sz = path.size(), pos = -1; for (int i = 0; i &amp;lt; sz - 1; i++) { if (path[i] == nei) { pos = i; break; } } cout &amp;lt;&amp;lt; sz - pos &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; for (int i = pos; i &amp;lt; sz; i++) { cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } exit(0); } dfs(nei, adj, vis, path, id); } path.</description></item></channel></rss>