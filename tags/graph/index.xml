<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graph on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/graph/</link><description>Recent content in Graph on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Fri, 22 Jul 2022 13:54:14 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces 986B. Petr and Permutations</title><link>https://snow-ham1949.github.io/posts/codeforces-986b-petr-and-permutations/</link><pubDate>Fri, 22 Jul 2022 13:54:14 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/codeforces-986b-petr-and-permutations/</guid><description>題目 有一個陣列 ${1, 2, &amp;hellip;, N}, (N \leq 10^6)$，Petr 喜歡對序列執行 $3n$ 次任取兩個數字交換的操作，Um_nik 喜歡做 $7n + 1$ 次，給定一個操作後的陣列，求是誰操作的。
作法 把 index 跟陣列數值想成是圖中有連接的點的話，一開始未操作的陣列會有 $n$ 個自環，每一次操作會增加或減少一個環，由 $3n$ 跟 $7n + 1$ 的奇偶性不同可以判斷是誰操作的。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long int ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;bool&amp;gt; vb; typedef vector&amp;lt;pii&amp;gt; vii; typedef vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; vvi; #define AC ios_base::sync_with_stdio(0), cin.tie(0); #define rep(i, j, k) for (int i = j; i &amp;lt; k; i++) #define all(v) (v).</description></item><item><title>CSES Round Trip</title><link>https://snow-ham1949.github.io/posts/cses-round-trip/</link><pubDate>Sun, 27 Feb 2022 22:41:56 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-round-trip/</guid><description>我一直以為我會找環欸，結果其實是我會找但要印出來就不會，我就笨 :p
題目 link 找圖中隨便一個環然後印路徑，如果沒有就輸出 IMPOSSIBLE。
作法 就是 dfs 一下(?)，最近在試著改掉開全域的壞習慣 :p，主要是我想要怎麼記祖先想很久，覺得開 parent 陣列又太肥，後來想到當參數傳下去不就好了嗎，笨笨的 :p
#include &amp;lt;bits/stdc++.h&amp;gt; #define AC \ ios::sync_with_stdio(0); \ cin.tie(0); \ cout.tie(0); using namespace std; #define DEBUG void dfs(int id, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;vis, vector&amp;lt;int&amp;gt; &amp;amp;path, int parent) { vis[id] = true; path.push_back(id); for (int nei : adj[id]) { if (nei == parent) { continue; } if (vis[nei]) { path.push_back(nei); int sz = path.size(), pos = -1; for (int i = 0; i &amp;lt; sz - 1; i++) { if (path[i] == nei) { pos = i; break; } } cout &amp;lt;&amp;lt; sz - pos &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; for (int i = pos; i &amp;lt; sz; i++) { cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } exit(0); } dfs(nei, adj, vis, path, id); } path.</description></item></channel></rss>