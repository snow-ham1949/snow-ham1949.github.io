<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/leetcode/</link><description>Recent content in Leetcode on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Wed, 20 Jul 2022 14:07:36 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 792. Number of Matching Subsequences</title><link>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</link><pubDate>Wed, 20 Jul 2022 14:07:36 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-792-number-of-matching-subsequences/</guid><description>試著記得每次都要寫複雜度（？ 題目 link 作法 一開始看到 tag 以為真的要寫 trie，後來才發現不用（用 trie 我也不會寫），用二分搜就可以了。 概念是先去紀錄 s</description></item><item><title>Leetcode 629. K Inverse Pairs Array</title><link>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</link><pubDate>Sun, 17 Jul 2022 21:27:49 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</guid><description>題目 link 作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。</description></item><item><title>Leetcode 2305. Fair Distribution of Cookies</title><link>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</link><pubDate>Thu, 14 Jul 2022 17:07:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</guid><description>題目 link 作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。 我一開始想跟 698 那題一樣做，不過這</description></item><item><title>Leetcode 698. Partition to K Equal Sum Subsets</title><link>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</link><pubDate>Wed, 13 Jul 2022 18:17:01 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</guid><description>好像比較了解 bit manipulation 可以幹嘛了（？） 題目 link 做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣</description></item><item><title>Leetcode 473. Matchsticks to Square</title><link>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</link><pubDate>Tue, 12 Jul 2022 23:20:53 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</guid><description>不會 dp 也不會 bit manipulation QAQ 題目 link 作法 dfs 一個最簡單的做法可以直接 recursion, code 如下 class Solution { public: bool chk(vector&amp;lt;int&amp;gt;&amp;amp; side, vector&amp;lt;int&amp;gt;&amp;amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i &amp;lt;</description></item><item><title>Leetcode 1696. Jump Game VI</title><link>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</link><pubDate>Sun, 10 Jul 2022 00:19:10 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</guid><description>題目 link 作法 令 dp[i] 為以 $i$ 為起點到終點能獲得的最大分數。如果枚舉可以走的範圍內最大的話複雜度會是 $O(nk)$ 會 TLE，所以可以用 deque 或是 priority_queue 來優化，維護一個可以</description></item><item><title>Leetcode 32. Longest Valid Parentheses</title><link>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</link><pubDate>Thu, 07 Jul 2022 21:17:42 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</guid><description>我真的不會 dp QwQ 題目 link 作法 可以先從基礎題開始想，就是判合法括號字串，這個用 stack 就可以解決（其實這題也可，但我想練 dp），從這個的想法出發的話，可</description></item><item><title>Leetcode 1354. Construct Target Array With Multiple Sums</title><link>https://snow-ham1949.github.io/posts/leetcode-1354-construct-target-array-with-multiple-sums/</link><pubDate>Fri, 24 Jun 2022 20:55:17 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1354-construct-target-array-with-multiple-sums/</guid><description>題目 link 作法 我是看 hint 才會的 QQ，hint 就是這題其實要反著做，就是說如果 target array 是可以被構造出來的話，逆推回去就應該是對的。 作法是把最大值一個一個</description></item><item><title>Leetcode 96. Unique Binary Search Trees</title><link>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</link><pubDate>Sat, 12 Feb 2022 19:13:27 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</guid><description>忘記數學了所以來複習一下 :p 題目 link 作法 如果假設有 $n$ 個節點的二元樹有 $G_n$ 個，其中以 $i$ 節點為根的數目有 $F_i$ 個，那麼 $$ G_n = F_1 + F_2 + &amp;hellip; + F_n$$ 根據二元樹的定義</description></item><item><title>Leetcode 45. Jump Game II</title><link>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</link><pubDate>Fri, 04 Feb 2022 17:26:23 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</guid><description>寒假因為很無聊就來刷題，絕對不是因為我很廢 :p 題目 link 作法 我是先想到 $O(n^2)$ 的做法，對於每個位置 $i$ 都去看前面的位置 $j$ 能不能走得更遠，如果可以的話就把 $i$</description></item></channel></rss>