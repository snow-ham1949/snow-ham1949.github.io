<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codeforces on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/codeforces/</link><description>Recent content in Codeforces on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 04 Sep 2023 21:49:45 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/codeforces/index.xml" rel="self" type="application/rss+xml"/><item><title>浮點數二分搜技巧</title><link>https://snow-ham1949.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 04 Sep 2023 21:49:45 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/%E6%B5%AE%E9%BB%9E%E6%95%B8%E4%BA%8C%E5%88%86%E6%90%9C%E6%8A%80%E5%B7%A7/</guid><description>今天寫了這題才知道原來浮點數二分搜要這樣寫。
原本我以為應該是要根據他想要的浮點數誤誤差當作 eps，然後寫成這樣
while (r - l &amp;gt; eps) { do binary search } 但那樣的話會 TLE，因為 r - l 的精度誤差有可能導致這個 while 會變成一個無窮迴圈，就是其實他已經達到 eps 了但是減起來大於。
所以應該要根據你的範圍跟他要的浮點數誤差來估計要砍半幾次，砍一次的精度是 0.5，所以砍 10 次的話大概會是 1e-3，所以根據你要的範圍 / 浮點數誤差 / 3 * 10 大概就是你要砍半的次數。
順便附上這題我的 code，我覺得想法不難只是需要知道浮點數二分搜怎麼寫而已。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; #define SZ(a) (int)(a).size() #define ALL(v) (v).begin(), (v).end() #define X first #define Y second #ifdef debug void trace_() { cerr &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } template &amp;lt;typename T1, typename.</description></item><item><title>Codeforces 1635D. Infinite Set</title><link>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</link><pubDate>Mon, 24 Oct 2022 21:57:08 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</guid><description>這題好難，我看了好多遍別人的題解才懂 QwQ
題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成
$x = a[i]$ $x = 2 * y + 1$ and $y \in S$ $x = 4 * y$ and $y \in S$ 問在集合 $S$ 中有多少元素小於 $2^p$，答案很大要 mod $1e9+7$
作法 因為 $p$ 的範圍會到 2e5，所以要用二進制來想這題。
對於一個二進位制為 $t$ 的數字，可以想像操作二就是左移一位然後末位補 1，操作二就是左移兩位（這邊就有點像 string）。所以可以觀察出一個結論，就是對於一個數字，把它增加 $i$ 位的方法有 $dp_i$ 種，這裡的 $dp$ 就是費波那契數列。
那這跟答案有什麼關係呢，假設一個二進位制為 $t$ 的數字存在在 $a$ 之中，那麼他擴展出的數字要小於 $p$ 的話，他擴展出的數字的數量就會是 $\sum_{i = 0}^{p - t} dp_i$，也就是不擴展、擴展一位、擴展兩位&amp;hellip;，那這件事情可以透過在算費波那契數列的時候算前綴和得到。
接下來考慮是不是每個 $a[i]$ 都會對答案有貢獻，其實不是這樣，因為 $S$ 是一個 set，不會有重複的數字出現，所以如果會重複出現就不用算。那題解的做法是說那就把會產生的數字想成一棵樹，我一直去看產生 $x$ 的 parent 有沒有已經被 create 過，如果有的話，那就代表 $x$ 已經被前面的數字（也就是 parent） create 過了，那就不能算進答案裡面（因為已經算過了），在這邊的話 parent 的意思就是說看他能不能逆推操作二或操作三。</description></item><item><title>Codeforces 986B. Petr and Permutations</title><link>https://snow-ham1949.github.io/posts/codeforces-986b-petr-and-permutations/</link><pubDate>Fri, 22 Jul 2022 13:54:14 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/codeforces-986b-petr-and-permutations/</guid><description>題目 有一個陣列 ${1, 2, &amp;hellip;, N}, (N \leq 10^6)$，Petr 喜歡對序列執行 $3n$ 次任取兩個數字交換的操作，Um_nik 喜歡做 $7n + 1$ 次，給定一個操作後的陣列，求是誰操作的。
作法 把 index 跟陣列數值想成是圖中有連接的點的話，一開始未操作的陣列會有 $n$ 個自環，每一次操作會增加或減少一個環，由 $3n$ 跟 $7n + 1$ 的奇偶性不同可以判斷是誰操作的。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long int ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;bool&amp;gt; vb; typedef vector&amp;lt;pii&amp;gt; vii; typedef vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; vvi; #define AC ios_base::sync_with_stdio(0), cin.tie(0); #define rep(i, j, k) for (int i = j; i &amp;lt; k; i++) #define all(v) (v).</description></item></channel></rss>