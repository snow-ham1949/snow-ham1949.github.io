<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Monotonic Stack on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/monotonic-stack/</link><description>Recent content in Monotonic Stack on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Tue, 04 Oct 2022 15:20:17 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/monotonic-stack/index.xml" rel="self" type="application/rss+xml"/><item><title>NEOJ 513 超大螢幕設置</title><link>https://snow-ham1949.github.io/posts/neoj-513-%E8%B6%85%E5%A4%A7%E8%9E%A2%E5%B9%95%E8%A8%AD%E7%BD%AE/</link><pubDate>Tue, 04 Oct 2022 15:20:17 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/neoj-513-%E8%B6%85%E5%A4%A7%E8%9E%A2%E5%B9%95%E8%A8%AD%E7%BD%AE/</guid><description>題目 link
作法 是單調隊列的經典題目，只是這題變成要往左往右看，看到第一個比它小的就停止，這樣就會知道以它的高度設置螢幕的話最寬能夠到多少。這邊用 vector 實作 stack 比較好寫（我看了別人的 code 覺得好棒），只是我不太習慣它 stack 的寫法，所以把 stack 存的值改成 {value, id} 這樣。
然後記得要開 long long ，我 WA 了好多次 QQ
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;ll, ll&amp;gt; pll; #define int ll #define SZ(a) (int)(a).size() #define endl &amp;#39;\n&amp;#39; #define X first #define Y second const int mxn = 2e5 + 5; int a[mxn], lhs[mxn], rhs[mxn], ans[mxn]; void solve() { int n; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; a[i]; vector&amp;lt;pll&amp;gt; stk(1, {0ll, 0ll}); // store {value, id} for (int i = 1; i &amp;lt;= n; i++) { while (a[i] &amp;lt;= stk.</description></item></channel></rss>