<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dp on 隨寫日誌</title><link>https://snow-ham1949.github.io/tags/dp/</link><description>Recent content in Dp on 隨寫日誌</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Erin Li</copyright><lastBuildDate>Mon, 24 Oct 2022 21:57:08 +0000</lastBuildDate><atom:link href="https://snow-ham1949.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces 1635D. Infinite Set</title><link>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</link><pubDate>Mon, 24 Oct 2022 21:57:08 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/codeforces-1635d-infinite-set/</guid><description>這題好難，我看了好多遍別人的題解才懂 QwQ 題目 給一個陣列，考慮一個無限的集合 $S$ 由符合以下條件之一的 $x$ 構成 $x = a[i]$ $x = 2 * y + 1$ and $y \in S$ $x = 4 * y$ and</description></item><item><title>CSES Tree Matching</title><link>https://snow-ham1949.github.io/posts/cses-tree-matching/</link><pubDate>Mon, 19 Sep 2022 21:51:48 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/cses-tree-matching/</guid><description>第一次接觸樹 dp OuO 題目 給一棵樹，找到最大的邊集合使得任兩邊不共享一個點，輸出集合大小。 作法 定義 如果是 array 版本的話（i.e. 給一個序列不能選相鄰的</description></item><item><title>Atcoder DP contest (持續更新中)</title><link>https://snow-ham1949.github.io/posts/atcoder-dp-contest/</link><pubDate>Sun, 28 Aug 2022 19:12:56 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/atcoder-dp-contest/</guid><description>紀錄一下自己練習 dp 的過程，最近在寫 icpc 培訓班的作業感受到自己的 dp 實在是太爛了&amp;hellip; 剛好被推薦有這個題單可以練習，所以就順便把自己不會</description></item><item><title>Leetcode 629. K Inverse Pairs Array</title><link>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</link><pubDate>Sun, 17 Jul 2022 21:27:49 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-629-k-inverse-pairs-array/</guid><description>題目 link 作法 $O(nk^2)$ 我以為會 TLE 然後剛剛測發現其實不會 QQ，可以定義 $dp[i][j]$ 是使用 1 ~ $i$ 的數字後，可以構成 $j$ 個 inversion pair 的數量，那答案就會是 $dp[n][k]$。</description></item><item><title>Leetcode 2305. Fair Distribution of Cookies</title><link>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</link><pubDate>Thu, 14 Jul 2022 17:07:07 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-2305-fair-distribution-of-cookies/</guid><description>題目 link 作法 bit manipulation + dp 這題跟 這題 蠻像的，不過這次是要盡可能平均分然後輸出這樣分以後一個小孩最多可能拿到的餅乾數。 我一開始想跟 698 那題一樣做，不過這</description></item><item><title>Leetcode 698. Partition to K Equal Sum Subsets</title><link>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</link><pubDate>Wed, 13 Jul 2022 18:17:01 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-698-partition-to-k-equal-sum-subsets/</guid><description>好像比較了解 bit manipulation 可以幹嘛了（？） 題目 link 做法 這題是 這題 的進化版（？），要分成 $k$ 堆，一樣可以用 bit + dp 做，然後這邊還有一個小技巧是直接用餘數，這樣</description></item><item><title>Leetcode 473. Matchsticks to Square</title><link>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</link><pubDate>Tue, 12 Jul 2022 23:20:53 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-473-matchsticks-to-square/</guid><description>不會 dp 也不會 bit manipulation QAQ 題目 link 作法 dfs 一個最簡單的做法可以直接 recursion, code 如下 class Solution { public: bool chk(vector&amp;lt;int&amp;gt;&amp;amp; side, vector&amp;lt;int&amp;gt;&amp;amp; matches, int id, int n) { if (id == n) { return side[0] == side[1] and side[1] == side[2] and side[2] == side[3]; } for (int i = 0; i &amp;lt;</description></item><item><title>Leetcode 1696. Jump Game VI</title><link>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</link><pubDate>Sun, 10 Jul 2022 00:19:10 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-1696-jump-game-vi/</guid><description>題目 link 作法 令 dp[i] 為以 $i$ 為起點到終點能獲得的最大分數。如果枚舉可以走的範圍內最大的話複雜度會是 $O(nk)$ 會 TLE，所以可以用 deque 或是 priority_queue 來優化，維護一個可以</description></item><item><title>Leetcode 32. Longest Valid Parentheses</title><link>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</link><pubDate>Thu, 07 Jul 2022 21:17:42 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-32-longest-valid-parentheses/</guid><description>我真的不會 dp QwQ 題目 link 作法 可以先從基礎題開始想，就是判合法括號字串，這個用 stack 就可以解決（其實這題也可，但我想練 dp），從這個的想法出發的話，可</description></item><item><title>Leetcode 96. Unique Binary Search Trees</title><link>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</link><pubDate>Sat, 12 Feb 2022 19:13:27 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-96-unique-binary-search-trees/</guid><description>忘記數學了所以來複習一下 :p 題目 link 作法 如果假設有 $n$ 個節點的二元樹有 $G_n$ 個，其中以 $i$ 節點為根的數目有 $F_i$ 個，那麼 $$ G_n = F_1 + F_2 + &amp;hellip; + F_n$$ 根據二元樹的定義</description></item><item><title>Leetcode 45. Jump Game II</title><link>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</link><pubDate>Fri, 04 Feb 2022 17:26:23 +0000</pubDate><guid>https://snow-ham1949.github.io/posts/leetcode-45-jump-game-ii/</guid><description>寒假因為很無聊就來刷題，絕對不是因為我很廢 :p 題目 link 作法 我是先想到 $O(n^2)$ 的做法，對於每個位置 $i$ 都去看前面的位置 $j$ 能不能走得更遠，如果可以的話就把 $i$</description></item></channel></rss>